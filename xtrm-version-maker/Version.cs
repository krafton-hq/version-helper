using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Threading.Tasks;
using StackExchange.Redis;

namespace VersionMakerNet
{
    public class FVersion
    {
        public static int MAX_VERSION_COLUMN = 4;
        public static int MAX_VERSION_STRING_SIZE = 1024;
        public static string VERSION_SOURCE_COMMENT =
"// CAUTION! DO NOT EDIT THIS FILE MANUALLY.\n" + 
"// This file is automatically generated from VersionMaker.exe for versioning automation.\n" + 
"// Author : erion@pubg.net, 2018.07~\n\n";
        public static string LOG_SPECIFIER = "[VersionMakerNet]";

        public FVersion()
        {
            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                Column[i] = 0;
            }
        }

        static public void Log(string LogStr)
        {
            Console.WriteLine(LOG_SPECIFIER + LogStr);
        }

        static public void Log(string LogStr, params object[] Args)
        {
            Console.WriteLine(LOG_SPECIFIER + LogStr, Args);
        }


        static public string GetVersionPosString(int Index, char PosChar = 'x')
        {
            string VersionPosition = "";
            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                if (i == Index)
                {
                    VersionPosition += "x";
                }
                else
                {
                    VersionPosition += "0";
                }

                if (i < (MAX_VERSION_COLUMN - 1))
                {
                    VersionPosition += ".";
                }
            }

            return VersionPosition;
        }

        public bool IsUsingRedis()
        {
            return RedisMuxer != null && RedisDB != null;
        }

        public bool LoadFromRedis(string InRedisHost)
        {
            if (0 < InRedisHost.Length)
            {
                RedisMuxer = ConnectionMultiplexer.Connect(InRedisHost + ":6379");
            }

            if (RedisMuxer == null)
            {
                Log("Failed to connect to redis server: " + InRedisHost);
                return false;
            }

            RedisDB = RedisMuxer.GetDatabase();
            if (RedisDB == null)
            {
                Log("Failed to get the redis DB: " + InRedisHost);
                return false;
            }

            bool bResult = true;
            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                int Version = GetRedisVersion(i);
                if (Version < 0)
                {
                    Log("Failed to get the redis version: {0}", i);
                    bResult = false;
                    break;
                }

                Column[i] = Version;
            }

            return bResult;
        }

        public bool LoadFromFile(string InFilepath)
        {
            string Text = File.ReadAllText(InFilepath);
            string[] SplittedText = Text.Split('.');

            int i = 0;
            foreach (string Value in SplittedText)
                Column[i++] = Int32.Parse(Value);
        
            return true;
        }

        public bool SaveToFile(string InFilepath)
        {
            string Result = "";

            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                if (i != 0)
                    Result += ".";
                Result += Column[i].ToString();
            }

            File.WriteAllText(InFilepath, Result);

            return true;
        }

        public bool SetByString(string InString)
        {
            if (InString.Length <= 0)
                return false;

            string[] SplittedText = InString.Split('.');

            if (SplittedText.Length != MAX_VERSION_COLUMN)
                return false;

            if (IsUsingRedis())
            {
                IBatch Batch = RedisDB.CreateBatch();

                List<Task<bool>> Tasks = new List<Task<bool>>();

                int RedisIndex = 0;
                foreach (string Value in SplittedText)
                {
                    Tasks.Add(Batch.StringSetAsync(GetRedisVersionKey(RedisIndex++), Value));
                }

                Batch.Execute();

                Batch.WaitAll(Tasks.ToArray());
            }

            int i = 0;
            foreach (string Value in SplittedText)
                Column[i++] = Int32.Parse(Value);

            return true;
        }

        public override string ToString()
        {
            string result = "";
            for (int i = 0; i < 4; ++i)
            {
                if (i != 0)
                    result += ".";
                result += Column[i].ToString();
            }

            return result;
        }


        public bool GenerateSourceFiles(string InFilepath)
        {
            if (InFilepath == null || InFilepath.Length <= 0)
            {
                InFilepath = "./GeneratedVersion";
            }

            string VersionFilename = "GeneratedVersion";

            // Header
            string HeaderFilename = VersionFilename;
            HeaderFilename += ".h";

            string HeaderFilepath = InFilepath;
            HeaderFilepath += HeaderFilename;

            bool bResult = GenerateHeader(HeaderFilepath);
            if (bResult == false)
                return false;

            return true;
        }
        public bool GenerateHeader(string InFilepath)
        {
            if (InFilepath == null || InFilepath.Length <= 0)
            {
                InFilepath = "./GeneratedVersion.h";
            }

            string Contents = VERSION_SOURCE_COMMENT;

            Contents += "#pragma once\n\n\n";

            // Include error
            Contents +=
                "#ifndef __FORCE_INCLUDE_VERSION_H__\n" +
                "\t#error \"Do not include this file for getting version.\"\n" +
                "#endif\n" + 
                "\n\n";

            // Stringify helpers
            Contents +=
                //"#define __VER_TEXT_2(x) L##x\n"
                "#define __VER_TEXT_2(x) TEXT(x)\n" +
                "#define __VER_TEXT(x) __VER_TEXT_2(x)\n" +
                "#define __VER_TOSTR_2(x) __VER_TEXT(#x)\n" +
                "#define __VER_TOSTR(x) __VER_TOSTR_2(x)\n" +
                "\n\n";

            // Columns
            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                Contents += "#define VERSION_COLUMN_";
                Contents += i.ToString();
                Contents += " ";
                Contents += Column[i].ToString();
                Contents += "\n";
            }

            Contents += "\n";

            // String
            Contents += "#define VERSION_STRING";
            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                Contents += " __VER_TOSTR(VERSION_COLUMN_";
                Contents += i.ToString();
                Contents += ")";

                if (i < (MAX_VERSION_COLUMN - 1))
                {
                    Contents += " __VER_TEXT(\".\")";
                }
            }

            Contents += "\n\n";

            if (Directory.Exists(Path.GetDirectoryName(InFilepath)))
            {
                File.WriteAllText(InFilepath, Contents);
            }
            else
            {
                Console.WriteLine("{0} is not valid, so skip to write {1}", Path.GetDirectoryName(InFilepath), Path.GetFileName(InFilepath));
            }

                return true;
        }

        public void Raise(int Index)
        {
            if (Index < 0 || Index > MAX_VERSION_COLUMN)
            {
                return;
            }

            if (IsUsingRedis())
            {
                IBatch Batch = RedisDB.CreateBatch();
                Task<long> IncrTask = Batch.StringIncrementAsync(GetRedisVersionKey(Index));

                List<Task<bool>> Tasks = new List<Task<bool>>();

                for (int i = MAX_VERSION_COLUMN - 1; i > Index; --i)
                {
                    Tasks.Add(Batch.StringSetAsync(GetRedisVersionKey(i), "0"));
                    Column[i] = 0;
                }

                Batch.Execute();

                Column[Index] = (int)Batch.Wait(IncrTask);

                Batch.WaitAll(Tasks.ToArray());
            }
            else
            {
                ++Column[Index];

                for (int i = MAX_VERSION_COLUMN - 1; i > Index; --i)
                {
                    Column[i] = 0;
                }
            }
        }

        public static bool operator ==(FVersion LHS, FVersion RHS)
        {
            if (LHS is null)
                return RHS is null;

            return LHS.Equals(RHS);
        }

        public static bool operator !=(FVersion LHS, FVersion RHS)
        {
            return !(LHS == RHS);
        }

        public override bool Equals(object InOther)
        {
            FVersion OtherVersion = (FVersion)InOther;
            if (OtherVersion == null)
                return false;

            bool bEquals = true;
            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                if (Column[i] != OtherVersion.Column[i])
                {
                    bEquals = false;
                    break;
                }
            }

            return bEquals;
        }

        public override int GetHashCode()
        {
            string result = "";
            for (int i = 0; i < 4; ++i)
            {
                if (i != 0)
                    result += ".";
                result += Column[i].ToString();
            }

            return result.GetHashCode();
        }

        public FVersion Clone()
        {
            FVersion CloneVersion = new FVersion();
            for(int i=0;i<MAX_VERSION_COLUMN;++i)
                CloneVersion.Column[i] = Column[i];

            return CloneVersion;
        }

        public bool Equals(FVersion InVersion)
        {
            for (int i = 0; i < MAX_VERSION_COLUMN; ++i)
            {
                if (InVersion.Column[i] != Column[i])
                    return false;
            }
            return true;
        }


        public int GetRedisVersion(int VersionIndex)
        {
            if (IsUsingRedis() == false)
            {
                return -1;
            }

            string VersionKey = GetRedisVersionKey(VersionIndex);
            string VersionString = RedisDB.StringGet(VersionKey);

            int Version = -1;
            int.TryParse(VersionString, out Version);

            return Version;
        }

        public string GetRedisVersionKey(int VersionIndex)
        {
            return "VERSION_COLUMN_" + VersionIndex.ToString();
        }

        private int[] Column = new int[MAX_VERSION_COLUMN];

        // redis relative
        ConnectionMultiplexer RedisMuxer = null;
        IDatabase RedisDB = null;
    }
}